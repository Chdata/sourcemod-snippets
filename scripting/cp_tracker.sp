/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>
#include <tf2>
#include "include/controlpoints.inc"

#pragma semicolon 1

#define MAX_CONTROL_POINTS 9 // The limit is technically 8, but ignore that for now
#define MAX_ROUNDS 10 // This is in theory unlimited, although practically the limit is 40,320.  Hydro has 8 rounds.

enum ControlPoint
{
	ControlPoint_Entity,
	bool:ControlPoint_Unlocked,
	TFTeam:ControlPoint_Owner,
	String:ControlPoint_Name[128]
}

enum ControlPointRound
{
	ControlPointRound_Entity,
	ControlPointRound_Priority,
	String:ControlPointRound_Name[128]
}

new g_cpCount;
new g_cpInfo[MAX_CONTROL_POINTS][ControlPoint];

new g_roundCount;
new g_cpRounds[MAX_ROUNDS][ControlPointRound];

new Handle:g_Kv_RoundStrings;

new curRoundEnt = -1;

new g_roundCPs[MAX_ROUNDS];

public Plugin:myinfo = 
{
	name = "Control Point Tracker",
	author = "Powerlord",
	description = "<- Description ->",
	version = "1.0",
	url = "<- URL ->"
}

public OnPluginStart()
{
	HookEvent("teamplay_round_selected", Event_SelectRound);
	HookEntityOutput("team_control_point", "OnUnlocked", Hook_OnUnlocked);
	HookEntityOutput("team_control_point", "OnRoundStartOwnedByTeam1", Hook_OnOwnerChangedToTeam1);
	HookEntityOutput("team_control_point", "OnRoundStartOwnedByTeam2", Hook_OnOwnerChangedToTeam2);
	HookEntityOutput("team_control_point", "OnOwnerChangedToTeam1", Hook_OnOwnerChangedToTeam1);
	HookEntityOutput("team_control_point", "OnOwnerChangedToTeam2", Hook_OnOwnerChangedToTeam2);
	HookEntityOutput("team_control_point", "OnCapReset", Hook_OnCapReset);
}

public OnMapStart()
{
	CloseHandle(g_Kv_RoundStrings);
	g_Kv_RoundStrings = INVALID_HANDLE;
}

public OnMapEnd()
{
	ResetPoints();
	ResetRounds();
}

public Native_FindCaps(Handle:plugin, numParams)
{
	new bool:multiRound = TF2_IsMultiRound();
	
	new size = GetNativeCell(2);
	new controlPoints[size];
	
	GetNativeArray(1, controlPoints, size);
	
	new TF2_GameMode:gameMode = TF2_DetectGameMode();
	
	switch (gameMode)
	{
		case TF2_GameMode_5CP:
		{
			return GetSymmetricCaps(controlPoints, size, multiRound);			
		}
		
		case TF2_GameMode_PL, TF2_GameMode_ADCP:
		{
			return GetADCaps(controlPoints, size, multiRound);
		}
		
		case TF2_GameMode_Arena, TF2_GameMode_PLR, TF2_GameMode_KOTH, TF2_GameMode_MvM:
		{
			return GetAllPoints(controlPoints, size, multiRound);
		}
	}
	return 0;
}

// A/D CP, PL
GetADCaps(controlPoints[], size, bool:multiRound)
{
	return 0;
}

// PLR, KOTH, TC, MvM
GetAllPoints(controlPoints[], size, bool:multiRound)
{
	return 0;
}

// 5CP
GetSymmetricCaps(controlPoints[], size, bool:multiRound)
{
	return 0;
}

public Event_SelectRound(Handle:event, const String:name[], bool:dontBroadcast)
{
	if (!multiRound)
	{
		return;
	}
	
	new String:curRound[128];
	GetEventString(event, "round", curRound, sizeof(curRound));
	
	new round = -1;
	
	// Since we're multiround, loop through the rounds to find the selected one
	while ((round = FindEntityByClassname(round, "team_control_point_round")) != -1)
	{
		new String:roundName[128];
		GetEntPropString(round, Prop_Data, "m_iName", roundName, sizeof(roundName));
		if (StrEqual(roundName, curRound))
		{
			new String:cpNames[1024];
			GetEntPropString(round, Prop_Data, "m_iszCPNames", cpNames, sizeof(cpNames));
			
			new String:buffers[MAX_CONTROL_POINTS][128];
			new cpCount = ExplodeString(cpNames, " ", buffers, sizeof(buffers), sizeof(buffers[]));
			
			new numCPs;
			for (new i = 0; i < cpCount; ++i)
			{
				for (new j = 0; j < g_cpCount; ++j)
				{
					if (StrEqual(g_cpInfo[j][ControlPoint_Name][0], buffers[i]))
					{
						g_roundCPs[numCPs] = g_cpInfo[j][ControlPoint_Entity];
						numCPs++;
					}
				}
			}
		}
	}
}

public Action:Cmd_PrintCPStatus(client, args)
{
	
}

public OnEntityCreated(entity, const String:classname[])
{
	if (StrEqual(classname, "team_control_point"))
	{
		SDKHook(entity, SDKHook_SpawnPost, OnCpSpawned);
	}
	else if (StrEqual(classname, "team_control_point_round"))
	{
		SDKHook(entity, SDKHook_SpawnPost, OnRoundSpawned);
	}
}

public OnRoundSpawned(entity)
{
	if (!IsValidEntity(entity))
	{
		return;
	}
	
	new String:roundName[128];
	GetEntPropString(entity, Prop_Data, "m_iName", roundName, sizeof(roundName));
	
	new index = GetRoundByName(roundName);
	
	if (g_Kv_RoundStrings == INVALID_HANDLE)
	{
		g_Kv_RoundStrings = CreateKeyValues("Rounds");
	}
	
	KvRewind(g_Kv_RoundStrings);
	
	new count = KvGetNum(g_Kv_RoundStrings, "count", 0) + 1;
	
	new String:strEntity[6];
	KvJumpToKey(g_Kv_RoundStrings, strEntity, true);
	IntToString(entity, strEntity, sizeof(strEntity));
	KvSetString(g_Kv_RoundStrings, "name", roundName);
	KvSetNum(g_Kv_RoundStrings, "priority", GetEntProp(entity, Prop_Data, "m_nPriority"));
}

public OnCpSpawned(entity)
{
	CpSetup(entity);
}

public OnEntityDestroyed(entity)
{
	CpCleanup(entity);
	
}

GetIndexOfCp(entity)
{
	if (entity <= 0 || entity > GetMaxEntities() || !IsValidEntity(entity))
	{
		return -1;
	}
	
	for (new i = 0; i < MAX_CONTROL_POINTS; ++i)
	{
		new cpEnt = EntRefToEntIndex(g_cpInfo[i][ControlPoint_Entity]);
		if (entity == cpEnt)
		{
			return i;
		}
	}
	
	return -1;
}

GetIndexOfRound(entity)
{
}

GetIndexOfRoundByName(const String:name[])
{
	for (new i = 0; i < g_roundCount; ++i)
	{
		if (StrEqual(name, g_cpRounds[i][ControlPointRound_Name]))
		{
			return i;
		}
	}
	return -1;
}

CpSetup(entity)
{
	new index = GetEntProp(entity, Prop_Data, "m_iPointIndex");
	
	new cpData[ControlPoint]; // Work around bug with GetEntPropString and sizes
	cpData[ControlPoint_Entity] = EntIndexToEntRef(entity);
	cpData[ControlPoint_Unlocked] = bool:GetEntProp(entity, Prop_Data, "m_bLocked");
	cpData[ControlPoint_Owner] = TFTeam:GetEntProp(entity, Prop_Data, "m_iDefaultOwner");
	GetEntPropString(entity, Prop_Data, "m_iName", cpData[ControlPoint_Name], sizeof(cpData[ControlPoint_Name]));
	g_cpInfo[index] = cpData;
}

GetLowestCp(cps[], cpCount)
{
}

GetCenterCp(cps[], cpCount)
{
}

CpCleanup(entity)
{
	new index = GetIndexOfCp(entity);
	if (index > -1)
	{
		ResetPoint(index);
	}
}

ResetPoints()
{
	for (new i = 0; i < g_cpCount; ++i)
	{
		ResetPoint(i);
	}
	
	g_cpCount = 0;
}

ResetPoint(index)
{
	g_cpInfo[index][ControlPoint_Entity] = 0;
	g_cpInfo[index][ControlPoint_Unlocked] = false;
	g_cpInfo[index][ControlPoint_Owner] = TFTeam_Unassigned;
	g_cpInfo[index][ControlPoint_Name][0] =   '\0';
}

ResetRounds()
{
	for (new i = 0; i < g_roundCount; ++i)
	{
		ResetRound(i);
	}

	g_roundCount = 0;
}

ResetRound(index)
{
	g_cpRounds[index][ControlPointRound_Entity] = 0;
	g_cpRounds[index][ControlPointRound_Priority] = 0;
	g_cpRounds[index][ControlPointRound_Name][0] = '\0';
}

public Hook_OnUnlocked(const String:output[], caller, activator, Float:delay)
{
	new index = GetIndexOfCp(caller);
	
	if (index == -1)
	{
		return;
	}

	g_cpInfo[index][ControlPoint_Unlocked] = true;
}

public Hook_OnOwnerChangedToTeam1(const String:output[], caller, activator, Float:delay)
{
	new index = GetIndexOfCp(caller);
	
	if (index == -1)
	{
		return;
	}
	
	g_cpInfo[index][ControlPoint_Owner] = TFTeam_Red;
}

public Hook_OnOwnerChangedToTeam2(const String:output[], caller, activator, Float:delay)
{
	new index = GetIndexOfCp(caller);
	
	if (index == -1)
	{
		return;
	}

	g_cpInfo[index][ControlPoint_Owner] = TFTeam_Red;
}

public Hook_OnCapReset(const String:output[], caller, activator, Float:delay)
{
	new index = GetIndexOfCp(caller);
	
	if (index == -1)
	{
		return;
	}

	g_cpInfo[index][ControlPoint_Owner] = TFTeam_Unassigned;
}
